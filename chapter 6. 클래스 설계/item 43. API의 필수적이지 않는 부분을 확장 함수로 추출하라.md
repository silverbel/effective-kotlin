# 아이템 43. API의 필수적이지 않는 부분을 확장 함수로 추출하라

클래스의 함수를 정의할 때, 메서드를 멤버로 정의할 것인지 아니면 확장함수로 정의할 것인지 결정해야한다.

둘은 사실 비슷하며 두 방식은 우월을 가리기 힘들다는 점을 알아야한다.

장점과 단점 모두 가지고 있어 상황에 맞게 사용하는 것이 옳다.

우선 멤버 함수와, 확장 함수의 차이점을 알아보자.

## 멤버 함수와 확장 함수의 차이

### 확장 함수는 따로 가져와서 사용한다.
  - 일반적으로 확장 함수는 다른 패키지에 위치
  - 확장 함수는 직접 멤버를 추가할 수 없는 경우, 데이터와 행위를 분리하도록 설계된 프로젝트에서 사용
  - 필드가 있는 프로퍼티는 클래스에 있어야 하지만, 메서드는 클래스의 public API만 활용하면 어디에 위치하든 상관없음
  - `import`를 해서 사용하니 같은 타입에 같은 이름으로 여러 개를 만들 수 있음 -> 같은 이름으로 다른 동작을 하는 확장이 있으면 위험 -> 차라리 멤버로

### 확장 함수는 `virtual`이 아님
  - 파생 클래스(서브 클래스)에서 오버라이드할 수 없다.
  - 확장 함수는 컴파일 시점에 정적으로 선택되어 가상 멤버 함수와 다르게 동작
  - 상속을 목적으로 설계된 요소는 확장 함수로 만들면 안됨
```kt
open class C
class D: C()
fun C.foo() = "c"
fun D.foo() = "d"

fun main() {
    val d = D()
    print(d.foo()) //d
    val c: C = d
    print(c.foo()) // c
    
    print(D.foo()) // d
    print(D() as C).foo()) // c
}
```
결과가 아주 개판이다 이유는 확장 함수는 `첫 번째 아규먼트로 리시버가 들어가는 일반 함수`로 컴파일되기 때문

### 확장 함수는 클래스가 아닌 타입에 정의
- 타입에 정의하기 때문에 nullable 또는 구체적인 제네릭 타입에도 확장 함수 정의 가능
```kt
  // nullble 
  inline fun CharSequence?.isNullOrBlank(): Boolean {
      contract {
        returns(false) implies (this@isNullOrBlank != null)
      }

      return this == null || this.isBlank()
  }
      
  // 구체적인 제너릭 타입
  public fun Iterable<Int>.sum(): Int {
      var sum :Int = 0
      for (element in this) {
        sum += element
      }
      return sum
}
```

### 확장 함수는 클래스 레퍼런스에서 멤버로 표시되지 않음

확장 함수는 클래스 레퍼런스에서 멤버로 표시되지 않기 때문에 어노테이션 프로세서가 따로 처리하지 않음

## 멤버 함수와 확장 함수의 차이 정리
1. 확장 함수는 읽어 들여야 한다.
2. 확장 함수는 virtual이 아니다
3. 멤버 함수는 높은 우선 순위를 갖는다.
4. 확장 함수는 클래스 위가 아니라 타입 위에 만들어진다.
5. 확장 함수는 클래스 레퍼런스에 나오지 않는다.

확장 함수는 더 많은 자유와 유연성을 준다. -> 약간의 혼동이 발생할 수 있지만,

API의 필수적인 부분은 멤버로 두고 필수적이지 않은 부분은 확장 함수로 만드는 것이 좋다.
